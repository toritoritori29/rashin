# Day2 epollによるイベント駆動型の実装 

## 目標
* epollを使ってacceptが処理をブロックしないようにする


Day1で作成したプログラムの問題点として、acceptが処理をブロッキングするため適切にSIGINTシグナルがハンドリングされない.
この問題を解決するために、epollを使ってlistenしているsocketに入力があったときに初めてaccept処理を動かすようにする.


## epollとは
ManPageから引用するとepollとは以下のようなAPIである.
> epoll API は poll(2) と同様の処理を行う、つまり、複数のファイルディスクリプタを監視し、その中のいずれか入出力可能な状態であるかを確認する.


簡単に言うとepollインスタンスにファイルディスクリプタを登録しておくと、そのファイルディスクリプタが入出力可能になったら通知してくれる仕組みである.
またepollは待機する秒数を指定できる. acceptで処理をブロックし続けるのではなく, epollでaccept可能かどうかを判定し続けるループに実装しなおすことで, 
Day1で問題になっていた, シグナルを適切にハンドリングできない問題を解決できるようになる.


またepollの機能を応用することで, リクエストを受け取る、レスポンスを受け取るなどのIO処理に関しても、待機している間に別の処理を実行しておくことができるようになる(IOの多重化）.
Webサーバーとして有名なnginxもIOをepollなどの方法を使ってIOを多重化し、非同期的に処理を行うことで優れたパフォーマンスを達成している.


epollを使うには以下のような順序でシステムコールを呼び出していく.

1. epoll_create - 新規のepollインスタンスを作成する.
2. epoll_ctl - 監視したいファイルディスクリプタを登録する.
2. epoll_wait - 登録したファイルディスクリプタに何かしらのeventが発生するまで待機する. timeoutで指定した時間を超えた場合には待機を中断する.


epollを使うことで[epoll_ctlのManPage](https://man7.org/linux/man-pages/man2/epoll_ctl.2.html)に記載のあるイベントを監視することができる.
read, writeだけでなくsocketが閉じたか、ハングアップしたかなども検知できる.


ManPageにはエッジトリガー, レベルトリガーという単語が記載されているが、
これはepoll_waitが「イベントが発生した瞬間を検知するか」または「イベントが発生している状態を検知するか」という違いがあるようだ.
詳細はこちらのURLが詳しかったので[こちらを](https://mackey-lab.hatenablog.com/entry/2015/04/22/005214)参照.


epollの導入によってacceptによってメインループがブロックされなくなり, 適切にシグナルをハンドリングすることができるようになった。
一方で一度acceptされてからレスポンスを返す処理はまだ同期的に実装されているため、複数のレスポンスを並行して処理することはできない。
今後の改修で各リクエスト・レスポンスをepollを使って非同期的に処理することをできるようにする。


## 実装


## 参考文献
* [ManPage - epoll](https://linuxjm.osdn.jp/html/LDP_man-pages/man7/epoll.7.html)
* [nixのepoll周辺の実装](https://docs.rs/nix/latest/src/nix/sys/epoll.rs.html#60-62)
* [サーバー入門、非同期処理入門、epoll 入門](https://blog.ojisan.io/how-to-epoll/)
